Программирование на языке C: Основы системных вызовов

Глава 1: Процессы в Unix-системах

В Unix-подобных операционных системах процесс представляет собой экземпляр выполняемой программы. Каждый процесс имеет уникальный идентификатор (PID) и собственное адресное пространство.

Системный вызов fork() создает точную копию текущего процесса. После успешного выполнения fork() в системе существуют два практически идентичных процесса:

- Родительский процесс (родитель) - исходный процесс
- Дочерний процесс (потомок) - вновь созданный процесс

Основные различия между процессами:
1. Возвращаемое значение fork()
2. Идентификатор процесса (PID)
3. Идентификатор родительского процесса (PPID)
4. Некоторые статистические данные

Глава 2: Замена образа процесса

Системный вызов exec() заменяет текущий образ процесса новым образом. Это означает, что код, данные и стек процесса полностью заменяются содержимым новой программы.

Существует несколько вариантов функции exec():
- execl() - принимает список аргументов
- execv() - принимает массив аргументов  
- execlp() - ищет программу в PATH
- execvp() - комбинация execv() и поиска в PATH

После успешного выполнения exec():
- Программа продолжает выполняться с функции main() новой программы
- PID процесса сохраняется
- Открытые файловые дескрипторы (кроме помеченных FD_CLOEXEC) остаются открытыми

Глава 3: Синхронизация процессов

Родительский процесс может ожидать завершения дочернего процесса с помощью системных вызовов wait(), waitpid() или waitid().

Функция wait():
- Блокирует выполнение родителя до завершения любого дочернего процесса
- Возвращает PID завершившегося процесса
- Позволяет получить статус завершения

Функция waitpid():
- Позволяет ожидать конкретный дочерний процесс
- Предоставляет дополнительные опции управления
- Может быть неблокирующей с флагом WNOHANG

Глава 4: Практический пример

Рассмотрим типичный сценарий использования fork-exec-wait:

1. Родительский процесс вызывает fork()
2. В дочернем процессе вызывается exec() для запуска новой программы
3. Родительский процесс вызывает wait() для ожидания завершения потомка
4. После завершения дочернего процесса родитель продолжает выполнение

Этот механизм является фундаментальным для создания командных оболочек, системных демонов и многих других компонентов Unix-систем.

Глава 5: Обработка ошибок

При работе с системными вызовами необходимо всегда проверять возвращаемые значения:

- fork() возвращает -1 при ошибке
- exec() возвращает управление только в случае ошибки
- wait() возвращает -1 при ошибке или 0 с флагом WNOHANG

Типичные причины ошибок:
- Недостаток системных ресурсов
- Некорректные аргументы
- Отсутствие прав доступа
- Несуществующий файл программы

Глава 6: Дополнительные аспекты

Зомби-процессы:
- Процесс, который завершился, но его статус не был прочитан родителем
- Занимает запись в таблице процессов
- Исчезает когда родитель вызывает wait()

Сиротские процессы:
- Дочерний процесс, родитель которого завершился
- Передается под управление процесса init (PID 1)
- Автоматически обрабатывается системой

Глава 7: Заключение

Механизм fork-exec-wait является краеугольным камнем многозадачности в Unix-системах. Понимание этих системных вызовов необходимо для эффективного программирования на системном уровне.

Данный текст предназначен для учебных целей и демонстрации работы с процессами в операционных системах семейства Unix.

Конец файла.